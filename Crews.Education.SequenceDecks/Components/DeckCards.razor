@using Crews.Education.SequenceDecks.Models
@using Microsoft.AspNetCore.WebUtilities
@inject IDeckService DeckService
@inject AppStateService AppState
@inject NavigationManager Navigation
@inject WindowService Window
@implements IDisposable

@if (cards is not null && cards.Length > 0)
{
		
	<div class="progress-indicator">
		<span>@(currentCardIndex + 1) / @cards.Length</span>
	</div>
	
	<div class="card-stack-container">
		@for (int i = currentCardIndex; i < Math.Min(currentCardIndex + cardsToDisplay, cards.Length); i++)
		{
			int stackPosition = i - currentCardIndex;
			<div class="card-wrapper @(i == currentCardIndex ? "top-card" : "") @(animatingCard == i ? "falling" : animatingCard >= 0 ? "rising" : "")" 
				 style="--stack-position: @stackPosition; z-index: @(cardsToDisplay - stackPosition);"
				 @onclick="() => HandleCardClickAsync(currentCardIndex)">
				<Card Color="@cards[i].Color" Value="@cards[i].Value"></Card>
			</div>
		}
	</div>

	<div class="controls">
		<IconButton IconName="home" OnClick="ReturnToDeckSelectionAsync" />
	</div>
}

@code {
	private Deck.Card[]? cards;
	private int currentCardIndex = 0;
	private int animatingCard = -1;
	private const int cardsToDisplay = 3;

	protected override async Task OnInitializedAsync()
	{
		AppState.OnChange += StateHasChanged;
		Navigation.LocationChanged += OnLocationChanged;
		await LoadDecksFromUrlAsync();
	}

	protected override async Task OnParametersSetAsync() => await LoadDecksFromUrlAsync();

	private async void OnLocationChanged(object? sender, LocationChangedEventArgs e)
	{
		await LoadDecksFromUrlAsync();
		StateHasChanged();
	}

	public void Dispose() 
	{
		AppState.OnChange -= StateHasChanged;
		Navigation.LocationChanged -= OnLocationChanged;
	}

	private async Task LoadDecksFromUrlAsync()
	{
		var uri = Navigation.ToAbsoluteUri(Navigation.Uri);
		var queryParams = QueryHelpers.ParseQuery(uri.Query);

		if (queryParams.TryGetValue("decks", out var deckParams) && !string.IsNullOrEmpty(deckParams))
		{
			var selectedDeckSlugs = deckParams.ToString().Split(',', StringSplitOptions.RemoveEmptyEntries)
				.Select(slug => slug.Trim())
				.Where(slug => !string.IsNullOrEmpty(slug))
				.ToHashSet();

			if (selectedDeckSlugs.Count > 0)
			{
				IEnumerable<Deck>? allDecks = await DeckService.GetDecksAsync();
				var selectedDecks = allDecks?
					.Where(d => selectedDeckSlugs.Contains("all") || selectedDeckSlugs.Contains(d.Slug)) 
					?? Enumerable.Empty<Deck>();

				var combinedCards = new List<Deck.Card>();
				foreach (var deck in selectedDecks)
				{
					combinedCards.AddRange(deck.GetCards());
				}

				if (queryParams.TryGetValue("shuffle", out var shuffleParams) && shuffleParams.ToString().Equals("true", StringComparison.InvariantCultureIgnoreCase))
				{
					var random = new Random();
					cards = combinedCards.OrderBy(c => random.Next()).ToArray();
				}
				else
				{
					cards = combinedCards.ToArray();
				}
				currentCardIndex = 0;

				return;
			}
		}

		// No valid decks in URL; return to selector.
		await ReturnToDeckSelectionAsync();
	}

	private async Task HandleCardClickAsync(int cardIndex)
	{
		AppState.StartBackground();

		if (cardIndex != currentCardIndex || cards == null) return;

		if (cardIndex == cards.Length - 1)
		{
			await ReturnToDeckSelectionAsync();
			return;
		}

		animatingCard = cardIndex;
		StateHasChanged();

		await Task.Delay(500);

		if (currentCardIndex < cards.Length - 1)
		{
			currentCardIndex++;
		}

		animatingCard = -1;
		StateHasChanged();
	}

	private async Task ReturnToDeckSelectionAsync()
	{
		await Window.ExitFullscreenAsync();
		Navigation.NavigateTo("/");
	}
}
